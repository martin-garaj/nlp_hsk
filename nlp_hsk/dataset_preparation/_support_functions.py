# -*- coding: utf-8 -*-
"""
This file includes support functions for processing datasets. These functions
should include all functional elements that get often repeated in the 
"processing_" scripts.
"""

from pathlib import Path
import json
import pprint
from datetime import date

def save2file(structure_to_save, structure_name, path_to_output_folder, formatter='pprint'):
    """
    This function generates a ".py" file containing a strucute 
    (nested dictionary) in human readable form.

    Parameters
    ----------
    structure_to_save : <dict>
        Nested dictionary containing data.
    structure_name : <str>
        Name of the structure.
    path_to_output_folder : <str>
        Path to folder where the produced is to be stored.

    Returns
    -------
    None.

    """
    # prepare intro string
    today_date = date.today().strftime("%Y/%m/%d")
    license_name = 'MIT'
    intro = \
    '""" \n'\
    +'AUTHOR: Martin Garaj PhD.\n'\
    +'UPDATED: '+today_date+'\n'\
    +'LICENSE: '+license_name+'\n'\
    +'CONTRIBUTORS: "YOUR_NAME_HERE", '\
    +'\n\n'\
    +'This file includes "'+structure_name+'" generated by "process_'\
    +structure_name+'.py".\n'\
    +'The file is human-readable, and is meant to be edited by hand'\
    +' (or by a script) \nin case of erros.\n'\
    +'Human-readable format allows for a simple visual check in git,\n'\
    +' when the edits can be "diff"-ed from original file to see the changes.\n'\
    +'""" \n\n'
    
    # save the processed data
    with open(Path(path_to_output_folder,structure_name+'.py'), 'w') as file:
        
        # use json format
        if formatter == 'json':
            dictionary_as_json = json.dumps(structure_to_save, 
                                            indent=2,
                                            sort_keys=True,
                                            ensure_ascii=False)
            # replace JSON 'null' witn pythons 'None'
            dictionary_as_json = dictionary_as_json.replace('null', 'None')
            # replace " with ' for better readability
            dictionary_as_json = dictionary_as_json.replace('"', "'")
            # add dictionary name 
            dictionary_as_json = structure_name+' = \\\n'+dictionary_as_json
            # add intro
            dictionary_as_json = intro + dictionary_as_json
            # write file
            file.write(dictionary_as_json)
        # use pprint format
        elif formatter == 'pprint':
            dictionary_as_pprint = pprint.pformat(structure_to_save,  
                                                  indent=3, 
                                                  width=1,
                                                  depth=100,
                                                  compact=False,
                                                  sort_dicts=True)
            # add dictionary name 
            dictionary_as_pprint = structure_name+' = \\\n'+dictionary_as_pprint
            # add intro
            dictionary_as_pprint = intro + dictionary_as_pprint
            # write file
            file.write(dictionary_as_pprint)
        else:
            raise ValueError('formatter = '+formatter\
                             +', only "json", "pprint" is allowed.')


def locate_ignored_characters_in_context(ignored_symbols, 
                                         context, 
                                         check_ignored_symbols_in_valid_context):
    invalid_substring = None
    # 1) check whether context includes any characters that are suspected 
    #    to be ignored
    for ignore_this in ignored_symbols:
        if ignore_this in context:
            # characters to be ignored are always between brackets （ ... ）
            bracket_start_index = context.find('（')
            bracket_end_index = context.find('）')
            
            # check the meaning of the character wo be ignored within a 
            if (bracket_start_index+bracket_end_index) == -2:
                # character is outside of brackets, 
                # therefore it is definitely not idnored 
                if ignore_this not in check_ignored_symbols_in_valid_context:
                    check_ignored_symbols_in_valid_context.append(ignore_this)
            elif bracket_start_index == -1 or bracket_end_index == -1:
                raise RuntimeError('ERROR: This means the context is missing' \
                      +' opening or closing bracket')
            else:
                # check the context between the brackets
                between_brackets = \
                    context[bracket_start_index+1:bracket_end_index]
                # '、' delimits the symbols, which are usually ignored
                number_of_delimiters = between_brackets.count('、')
                # symbols are definitely ignored, when they are just listed 
                # in a bracket, delimtied by '、', 
                # the following finalizes this procedure
                if number_of_delimiters+1 >= len(between_brackets)-number_of_delimiters:
                    invalid_substring = \
                        context[bracket_start_index:bracket_end_index+1]

    return invalid_substring, check_ignored_symbols_in_valid_context
        
